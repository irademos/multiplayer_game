# Blender 4.x script: export intact/chunks GLBs + area.json
import bpy, json, os, math
from mathutils import Matrix
import addon_utils

def center_single_mesh_to_origin(obj):
    """Move a joined mesh's geometry to the origin and zero its object transform."""
    W = obj.matrix_world.copy()
    invW = W.inverted()
    # bake inverse into mesh data, then zero the object transform
    if obj.type == 'MESH':
        obj.data.transform(invW)
    else:
        for ch in obj.children:
            if ch.type == 'MESH':
                ch.data.transform(invW)
    obj.matrix_world = Matrix.Identity(4)


CANDIDATES = [
    "bl_ext.blender_org.cell_fracture",  # Blender 4.x Extensions
    "object_fracture_cell",              # legacy bundled add-on name
]

def enable_cell_fracture():
    for mod in CANDIDATES:
        try:
            addon_utils.enable(mod, default_set=True, persistent=True)
            print(f"‚úÖ Enabled: {mod}")
            break
        except Exception as e:
            print(f"‚ö†Ô∏è Could not enable {mod}: {e}")
    else:
        available = [m.__name__ for m in addon_utils.modules()]
        raise RuntimeError("Cell Fracture add-on not found. "
                           f"Available fracture-like modules: {[m for m in available if 'fracture' in m]}")

    # Confirm the operator exists on this Blender
    if not hasattr(bpy.ops.object, "add_fracture_cell_objects"):
        raise RuntimeError("Cell Fracture operator 'add_fracture_cell_objects' not available.")

def fracture_object(obj, pieces=35, margin=0.002):
    # Deselect everything, select only obj
    for o in bpy.context.selected_objects:
        o.select_set(False)
    obj.select_set(True)

    # Find a VIEW_3D area/region for a valid UI context
    area = next(a for a in bpy.context.window.screen.areas if a.type == 'VIEW_3D')
    region = next(r for r in area.regions if r.type == 'WINDOW')

    # Run the operator inside a context override (no positional ctx arg!)
    with bpy.context.temp_override(area=area, region=region,
                                   active_object=obj, object=obj,
                                   selected_objects=[obj], selected_editable_objects=[obj]):
        return bpy.ops.object.add_fracture_cell_objects(
            source={'PARTICLE_OWN'},
            source_limit=pieces,
            source_noise=0.0,
            cell_scale=(1, 1, 1),
            recursion=0,
            use_smooth_faces=True,
            use_sharp_edges=False,
            use_island_split=True,
            margin=margin,
            material_index=0,
            use_recenter=True,
            use_remove_original=True  # removes the temporary joined mesh we created
        )


enable_cell_fracture()

#bpy.ops.object.select_all(action='DESELECT')
#bpy.ops.mesh.primitive_cube_add(size=2)
#cube = bpy.context.active_object
#bpy.ops.object.duplicate()
#dup = bpy.context.active_object
#dup.location.x += 3.0
#bpy.ops.object.mode_set(mode='OBJECT')

#print(fracture_object(dup, pieces=20))  # should create shards

#error



# --- EDIT ME ---
PROJECT_ROOT = r"C:\Users\chris-dev\OneDrive - YAMAHA MOTOR CO., LTD\Documents\Visual Studio\project1\multiplayer_game"   # your Vite project root
ASSET_OUT_DIR    = os.path.join(PROJECT_ROOT, "public/assets/props")
AREA_JSON_PATH    = os.path.join(PROJECT_ROOT, "public/areas/demo/demo_area.json")
# --------------

# Blender 3.x ‚Äî Auto export intact+chunks GLBs for every placed object
# and write an area JSON matching your schema.
# --------------------------------------------------------------
FRACTURE_PIECES = 35         # 20‚Äì60 looks good, higher = heavier
FRACTURE_MARGIN = 0.002
ONLY_DESTRUCT_PREFIXES = ()  # e.g. ("prop_",) to limit fracture set
# -------------------------------

os.makedirs(ASSET_OUT_DIR, exist_ok=True)

def sanitize(name: str) -> str:
    base = "".join(c if (c.isalnum() or c in "_-") else "_" for c in name.strip())
    return base.lower().strip("_")

def select_none():
    for o in bpy.context.selected_objects:
        o.select_set(False)

def select_recursive(obj, only_mesh_children=False):
    """Select obj and (optionally only mesh) descendants."""
    select_none()
    stack = [obj]
    first = None
    while stack:
        o = stack.pop()
        if (not only_mesh_children) or (o.type == 'MESH'):
            o.select_set(True)
            if first is None:
                first = o
        stack.extend(list(o.children))
    bpy.context.view_layer.objects.active = first or obj

def mesh_descendants(obj):
    return [o for o in obj.children_recursive if o.type == 'MESH']

def has_mesh_descendants(obj):
    if obj.type == 'MESH':
        return True
    return any(c.type == 'MESH' for c in obj.children_recursive)

def is_top_level_asset(obj):
    if not has_mesh_descendants(obj):
        return False
    # Don't pick children if a parent already qualifies
    p = obj.parent
    while p:
        if has_mesh_descendants(p):
            return False
        p = p.parent
    return True

def export_selected_glb(path):
    bpy.ops.export_scene.gltf(
        filepath=path,
        export_format='GLB',
        use_selection=True,
        export_yup=True,
        export_apply=True,   # bake transforms into geometry
        # keep default materials/UVs
    )

def duplicate_to_single_mesh(root_obj):
    """Duplicate all mesh descendants of root into one joined mesh (applies transforms)."""
    # Gather meshes
    meshes = []
    if root_obj.type == 'MESH':
        meshes.append(root_obj)
    meshes.extend(mesh_descendants(root_obj))
    if not meshes:
        return None

    # Duplicate selected copies
    select_none()
    for m in meshes:
        m.select_set(True)
    bpy.context.view_layer.objects.active = meshes[0]
    bpy.ops.object.duplicate()
    dupes = bpy.context.selected_objects[:]

    # Make sure all dupes are real meshes (no instances) and join them
    for d in dupes:
        if d.type != 'MESH':
            try:
                bpy.context.view_layer.objects.active = d
                bpy.ops.object.convert(target='MESH')
            except:
                pass

    # Join
    if len(dupes) > 1:
        bpy.ops.object.join()
        joined = bpy.context.active_object
    else:
        joined = dupes[0]

    # Apply transforms so fracture works in object space
    bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)
    return joined

def run_cell_fracture(source_obj):
    """Fracture source_obj; return list of new shard objects."""
    before = set(bpy.data.objects)
    bpy.context.view_layer.objects.active = source_obj
    select_none()
    source_obj.select_set(True)

    try:
        fracture_object(source_obj, pieces=FRACTURE_PIECES)
    except Exception as e:
        print(f"‚ùå Cell fracture failed for {source_obj.name}: {e}")
        return []

    after = set(bpy.data.objects)
    created = [o for o in (after - before) if o.type == 'MESH']
    return created

def radians_tuple_from_matrix(m: Matrix):
    loc, rot, sca = m.decompose()
    eul = rot.to_euler('XYZ')
    return (
        (round(loc.x,6), round(loc.y,6), round(loc.z,6)),
        (round(eul.x,6), round(eul.y,6), round(eul.z,6)),
        (round(sca.x,6), round(sca.y,6), round(sca.z,6))
    )

# Choose candidate assets = top-level objects with meshes
candidates = [o for o in bpy.context.scene.objects if is_top_level_asset(o)]
if not candidates:
    raise RuntimeError("No mesh-containing top-level objects found in the scene.")

assets_dict = {}
instances = []
used_keys = set()

for obj in candidates:
    base = sanitize(obj.name)
    # ensure unique key
    key = base
    suffix = 1
    while key in used_keys:
        suffix += 1
        key = f"{base}_{suffix}"
    used_keys.add(key)

    intact_key  = f"{key}_intact"
    chunks_key  = f"{key}_chunks"
    intact_path = os.path.join(ASSET_OUT_DIR, f"{intact_key}.glb")
    chunks_path = os.path.join(ASSET_OUT_DIR, f"{chunks_key}.glb")

    # --- Export intact (origin-centered) ---
    select_recursive(obj, only_mesh_children=False)
    joined = duplicate_to_single_mesh(obj)   # your function that duplicates & JOINs
    center_single_mesh_to_origin(joined)

    select_none(); joined.select_set(True); bpy.context.view_layer.objects.active = joined
    export_selected_glb(intact_path)         # keep export_apply=True
    assets_dict[intact_key] = f"/assets/props/{os.path.basename(intact_path)}"

    # cleanup
    bpy.data.objects.remove(joined, do_unlink=True)

    # Determine if we should fracture this object
    should_fracture = True
    if ONLY_DESTRUCT_PREFIXES:
        should_fracture = any(obj.name.startswith(p) for p in ONLY_DESTRUCT_PREFIXES)

    # --- Export chunks (duplicate & fracture) ---
    chunk_url = None
    if should_fracture:
        joined = duplicate_to_single_mesh(obj)
        if joined:
            shards = run_cell_fracture(joined)
            # cleanup the joined source
            # Recenter all shards as a group to origin (use the original 'joined' world matrix)
            W = joined.matrix_world.copy()
            invW = W.inverted()
            for s in shards:
                if s.type == 'MESH':
                    s.data.transform(invW)
                s.matrix_world = Matrix.Identity(4)

            # Export shards origin-centered
            select_none()
            for s in shards: s.select_set(True)
            bpy.context.view_layer.objects.active = shards[0]
            export_selected_glb(chunks_path)
            assets_dict[chunks_key] = f"/assets/props/{os.path.basename(chunks_path)}"

            # cleanup shards
            for s in shards:
                try: bpy.data.objects.remove(s, do_unlink=True)
                except: pass


    # --- Instance entry (from original object‚Äôs world transform) ---
    loc, rot, sca = radians_tuple_from_matrix(obj.matrix_world)
    # JSON expects scalar scale; use X if nearly uniform, else 1 and stash vector
    if abs(sca[0]-sca[1])<1e-5 and abs(sca[0]-sca[2])<1e-5:
        scale_scalar = round(sca[0],6)
        scale_meta = None
    else:
        scale_scalar = 1.0
        scale_meta = [round(s,6) for s in sca]

    inst = {
        "id": key,
        "asset": intact_key,
        "position": list(loc),
        "rotationEuler": list(rot),
        "scale": scale_scalar,
        "tags": ["prop","destructible"] if should_fracture else ["static"],
        "meta": {
            "health": 50 if should_fracture else 0,
            "fractureId": chunks_key if chunk_url else ""
        }
    }
    if scale_meta:
        inst["meta"]["scaleVec"] = scale_meta  # optional hint if non-uniform

    instances.append(inst)
    print(f"‚úÖ {obj.name}: exported {intact_key}" + (f" + {chunks_key}" if chunk_url else " (no chunks)"))

# Write JSON
doc = {"version": 1, "assets": assets_dict, "instances": instances}
os.makedirs(os.path.dirname(AREA_JSON_PATH), exist_ok=True)
with open(AREA_JSON_PATH, "w", encoding="utf-8") as f:
    json.dump(doc, f, indent=2)
print(f"\nüìÑ Wrote {AREA_JSON_PATH} with {len(instances)} instances and {len(assets_dict)} assets")
